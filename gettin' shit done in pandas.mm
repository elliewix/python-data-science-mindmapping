<?xml version="1.0" encoding="UTF-8" standalone="no"?><map version="0.8.1"><node CREATED="1497319387555" ID="09ce698gan326g8q5nu5aqlno2" MODIFIED="1497319387555" TEXT="gettin' shit done in pandas"><node CREATED="1497319387556" ID="4ddqoebat8cribm5b7u721dgue" MODIFIED="1497319387556" POSITION="right" TEXT="make"><node CREATED="1497319387556" ID="6is3ja5ob15kmncu3sjp6vod45" MODIFIED="1497319387556" TEXT="dataframe"><node CREATED="1497319387556" ID="37dt4678p2tcf9jq111ies8l6k" MODIFIED="1497319387556" TEXT="from a file"><node CREATED="1497319387556" ID="0og5i6ebrm1i5h85kblus9655v" MODIFIED="1497319387556" TEXT="from a csv"><node CREATED="1497319387556" ID="2g8tru57tb5hpieufq1mkorb7b" MODIFIED="1497319387556" TEXT="pd.read_csv('file.csv', header=None, nrows=5)"/></node><node CREATED="1497319387556" ID="1dtcgroo09oni1u99aaosm6bof" MODIFIED="1497319387556" TEXT="from excel"><node CREATED="1497319387556" ID="4hk1h70a2obigfke44a23tgjus" MODIFIED="1497319387556" TEXT="pd.read_excel('file.xlsx')"/><node CREATED="1497319387556" ID="268sffv6fp0gg7r2jtuj12q08d" MODIFIED="1497319387556" TEXT="xlsx = pd.ExcelFile('file.xls')&#10;df = pd.read_excel(xlsx, 'Sheet1') to read specific sheets"/></node><node CREATED="1497319387556" ID="462e5h2dk3f0peho9ogk1h4nrr" MODIFIED="1497319387556" TEXT="with adjustments to"><node CREATED="1497319387556" ID="2dcv9grrr1ubtsnv8e58qhf5j4" MODIFIED="1497319387556" TEXT="set the index"><node CREATED="1497319387556" ID="6k0vmuqetu05fnh64as1a55aqf" MODIFIED="1497319387556" TEXT="df.index = list of values in order"/><node CREATED="1497319387556" ID="62rn72eindg051ibkq0l8frb33" MODIFIED="1497319387556" TEXT="index_col = n in read func"/></node><node CREATED="1497319387556" ID="6skoad839n63bhrjnf1680ppo6" MODIFIED="1497319387556" TEXT="header crap"><node CREATED="1497319387556" ID="6kskp9pqooqm5cn7d001kodmdc" MODIFIED="1497319387556" TEXT="nrows = n to skip rows"/><node CREATED="1497319387556" ID="0l4bm07h4oboj2ach5581vnl8a" MODIFIED="1497319387556" TEXT=" header=None bool to declare if there are headers"/></node></node></node><node CREATED="1497319387556" ID="2vouqtbl790i0j3p1a3ct93ikv" MODIFIED="1497319387556" TEXT="from memory"><node CREATED="1497319387556" ID="18li1qvcsc7rpq47k39dcmq7tg" MODIFIED="1497319387556" TEXT="from a dict"><node CREATED="1497319387556" ID="07n0mr54di57odd706h9o9oq76" MODIFIED="1497319387556" TEXT="pd.DataFrame(data_dict, columns = ['a', 'b', 'c'])"/></node></node></node></node><node CREATED="1497319387556" ID="0udad9mj64glv31d3j1lacp7iq" MODIFIED="1497319387556" POSITION="right" TEXT="access"><node CREATED="1497319387556" ID="4dqmimsvgv4mip0d7lgud1j4nm" MODIFIED="1497319387556" TEXT="columns"><node CREATED="1497319387556" ID="2jl78qpt6hisbltmkk9jtj60qd" MODIFIED="1497319387556" TEXT="by name"><node CREATED="1497319387556" ID="6poe8s4pb0p7jsknspunug6c44" MODIFIED="1497319387556" TEXT="df.loc[ : , [&quot;col1&quot;, &quot;col2&quot;]] gives you a df with those columns and all rows"/><node CREATED="1497319387556" ID="12o6ikact4p04llthdrk6dvk3d" MODIFIED="1497319387556" TEXT="df[[&quot;col1&quot;, &quot;col2&quot;]] will give you a df with many cols"/><node CREATED="1497319387556" ID="74t0u97clipm69dfmmhqgjbkrf" MODIFIED="1497319387556" TEXT="df[[&quot;colname&quot;]] will give you a dataframe"/><node CREATED="1497319387556" ID="4uvrdohve7prj3781afq345al1" MODIFIED="1497319387556" TEXT="df[&quot;col_name&quot;] will give you a Series"/></node><node CREATED="1497319387556" ID="3juor6lcd3c02im7e8r5jin7qk" MODIFIED="1497319387556" TEXT="by index position"><node CREATED="1497319387556" ID="4onoa2bp9pkvjllr182jb8gdtm" MODIFIED="1497319387556" TEXT="df.iloc[ :, [c1, c2, c3]] using 0 index"/></node></node><node CREATED="1497319387556" ID="7fh5l88v9iqt5pr73n3odninp7" MODIFIED="1497319387556" TEXT="rows"><node CREATED="1497319387556" ID="03dh9q9bchu3pld073v6i1mjv3" MODIFIED="1497319387557" TEXT="by index label"><node CREATED="1497319387558" ID="1hl15tm487bqdvtqenmjj6mm3r" MODIFIED="1497319387558" TEXT="df.loc[&quot;index label&quot;] gives you a row as a series"/><node CREATED="1497319387558" ID="63uaknkcgs63su6c87vjuet557" MODIFIED="1497319387558" TEXT="df.loc[[&quot;index label&quot;]] gives you a dataframe of the row"/><node CREATED="1497319387558" ID="675qd2a3vdnjhlu276u2lp4cmo" MODIFIED="1497319387558" TEXT="df.loc[[&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;]] for multiple rows in a data frame"/></node><node CREATED="1497319387558" ID="67bv75a059dr0c5ue5edpvrd2l" MODIFIED="1497319387558" TEXT="by index position"><node CREATED="1497319387558" ID="1iijhathclf6geic97pneqbh8s" MODIFIED="1497319387558" TEXT="df.iloc[[n]] to get a single row as a data frame"/><node CREATED="1497319387558" ID="3j7cees7b7ea7bodf6p5jue2dj" MODIFIED="1497319387558" TEXT="df.iloc[[n1, n2, n3]] to get multiple rows as a data frame"/><node CREATED="1497319387558" ID="05ucll94pmfp76tn6mu58op1u0" MODIFIED="1497319387558" TEXT="df[start-in:stop-ex] only slices work with this"/></node></node><node CREATED="1497319387558" ID="25kq2fr97vj216i8vumljqv97h" MODIFIED="1497319387558" TEXT="a row/column slice"><node CREATED="1497319387558" ID="6qtsl5a0k8hhndlh66qpv56gom" MODIFIED="1497319387558" TEXT="by index position"><node CREATED="1497319387558" ID="0tsvgqp9jd9d5m812ndnb560lp" MODIFIED="1497319387558" TEXT="df.iloc[[n1, n2, n3], [c1, c2, c3]] using position numbers, all 0 index"/></node><node CREATED="1497319387558" ID="2prvtvivts64jsj95udvik4ec8" MODIFIED="1497319387558" TEXT="by name"><node CREATED="1497319387558" ID="71fg6kjv9bqovco9950r5is4fr" MODIFIED="1497319387558" TEXT="df.loc[ [&quot;index 1&quot;, &quot;index 2&quot;], [&quot;column1&quot;, &quot;column2&quot;]] will return a data frame"/></node></node></node><node CREATED="1497319387558" ID="32q4gmaknmtl5rcjp1igl1m7o6" MODIFIED="1497319387558" POSITION="right" TEXT="find"/><node CREATED="1497319387558" ID="4i9pobljlf0m457ncoohc3f4gn" MODIFIED="1497319387558" POSITION="right" TEXT="compare values"><node CREATED="1497319387558" ID="5j1imbo2net1158aaemddqk2f7" MODIFIED="1497319387558" TEXT="by broadcasting a boolean operator over"><node CREATED="1497319387558" ID="2bhbserdpjes6v1a8ip08khoob" MODIFIED="1497319387558" TEXT="a series"><node CREATED="1497319387558" ID="35cejvppe27qq8f2ufnlcnggi6" MODIFIED="1497319387558" TEXT="series &lt; 3 will give another series with the bool values"/></node></node><node CREATED="1497319387558" ID="71l3uda719nci8meu2h6uorv00" MODIFIED="1497319387558" TEXT="of a series vs another series"><node CREATED="1497319387558" ID="2o58fkuvj75712rn5rbpct4s69" MODIFIED="1497319387558" TEXT="s1 &lt; s2 must be same len, will compare pair vals"/></node><node CREATED="1497319387558" ID="5ktb523csu9cuqbk1cq89cnq9v" MODIFIED="1497319387558" TEXT="with a compound boolean"><node CREATED="1497319387558" ID="2p53dq38ppph03q4sl36e29pfr" MODIFIED="1497319387558" TEXT="on arrays"><node CREATED="1497319387558" ID="4ckgl22ankc7aohgkc0uo2ilsp" MODIFIED="1497319387558" TEXT="np.logical_and(s1 &lt; 2, s1 &gt; 0)&#10;will run each of the statements, then&#10;give back to you an elementwise result &#10;based on the operator selected"/></node></node></node><node CREATED="1497319387558" ID="208iqj8hlbgsin3chof9gqaec8" MODIFIED="1497319387558" POSITION="right" TEXT="filter values"><node CREATED="1497319387558" ID="7gabdhshltgt86pm2i2bj0vnpn" MODIFIED="1497319387558" TEXT="on a data frame&#10;1) get column into a series&#10;2) run a comparison on that series&#10;3) put that bool series into dataframe in []"><node CREATED="1497319387558" ID="43sieuf18123othdih9piihqil" MODIFIED="1497319387558" TEXT="make a boolean series via df[&quot;col&quot;] &gt; 3 &#10;or other logical operations&#10;then df[mask]&#10;&#10;or df[mask calculation] as a one liner"/></node></node><node CREATED="1497319387558" ID="6nu4lc1fsfqa4fgvqj1cr3bcnu" MODIFIED="1497319387558" POSITION="left" TEXT="loop over to see stuff"><node CREATED="1497319387558" ID="6ubibrqhanuic55mtcic404tsg" MODIFIED="1497319387558" TEXT="a 1D np.array"><node CREATED="1497319387558" ID="2m6hgajckfh84fc3upao2fc8j0" MODIFIED="1497319387558" TEXT="for item in array works as normal"/></node><node CREATED="1497319387558" ID="0ru20behjgkoc3p22ogujehq0m" MODIFIED="1497319387558" TEXT="a 2D np.array"><node CREATED="1497319387558" ID="2ha28s238b8q4vffb0ru4pvm0i" MODIFIED="1497319387558" TEXT="classic for loop goes over subarrays rather than matching&#10;use for val in np.iditer(array_var) to go through "/></node><node CREATED="1497319387558" ID="10sosr70qo6vtfki5nkfm3alj8" MODIFIED="1497319387558" TEXT="a dictionary"><node CREATED="1497319387558" ID="5ssqh8j7mfili9d92h86p7etn4" MODIFIED="1497319387558" TEXT="for key, value in dict.items()"/></node><node CREATED="1497319387558" ID="6c4bn2qs03bc7e00suk9jc7lut" MODIFIED="1497319387558" TEXT="a dataframe"><node CREATED="1497319387558" ID="2g3mokhlbo15skgklfu4ih5ur3" MODIFIED="1497319387558" TEXT="for item in df&#10;will give you only column names"/><node CREATED="1497319387558" ID="28vpgrqf88e6t1d17l9ce1t6hm" MODIFIED="1497319387558" TEXT="for index, row in df.iterrows()&#10;will iterate over rows with label as key&#10;index will be a string(?) and row will be a series"/></node></node><node CREATED="1497319387558" ID="3vtjggqmseparbao1d76kpenv8" MODIFIED="1497319387558" POSITION="left" TEXT="loop over to do stuff"><node CREATED="1497319387558" ID="3tjs7cvjsb0v56f0jkbf52j1i6" MODIFIED="1497319387558" TEXT="a dataframe"><node CREATED="1497319387558" ID="3nc8vps9ra3s1o7lkcpngtrd8i" MODIFIED="1497319387558" TEXT="and add new column for each row"><node CREATED="1497319387558" ID="0mhvq10dc302cjolhhgul3lmte" MODIFIED="1497319387558" TEXT="use for index, row in df.iterrow():&#10;df.loc[index, &quot;new_col_name&quot;] = &quot;whatever&quot;&#10;will create that column  for that row, with the&#10;provided index and set the value to the assignment&#10;But this is inefficient"/><node CREATED="1497319387558" ID="6qsflpdk03kle892oj1m68hsnk" MODIFIED="1497319387558" TEXT="do this in an elementwise way via .apply()&#10;df[&quot;new_col_name&quot;] = df[&quot;real_column&quot;].apply(func)&#10;This will perform a mapping of that func over all contents&#10;of the column that apply is called upon. Those new vals&#10;will be spat into the new_col_name. Note ref'in the function as &#10;object rather than calling it inside of apply.&#10;&#10;When you want to call a function that is an object method, you &#10;reference the object type, so str.upper to uppercase a string."/></node></node></node><node CREATED="1497319387558" ID="4ike07oj2i19t98hsn1eo2v1tb" MODIFIED="1497319387558" POSITION="left" TEXT="timeseries"><node CREATED="1497319387558" ID="3n2plf29r7tmso140k421o8v18" MODIFIED="1497319387558" TEXT="When you have a df with a timeseries as the index, you can do smart things with it"/><node CREATED="1497319387558" ID="782hq95f7fqu13eb2mjvp3ti4l" MODIFIED="1497319387558" TEXT="You can slice by just the date ranges when the index is stored as datetime&#10;df['2007-01':'2007-03']"/><node CREATED="1497319387558" ID="434p67j5mqps8v9433dlec4ijm" MODIFIED="1497319387558" TEXT="plt.xticks(rotation = 60) to rotate the xlabs&#10;plt.xticks(dates, labels, rotation = 60)&#10;looks like dates is a datetime index that corresponds to the&#10;data being plotted, and the labels is a formatted list of strings that correspond&#10;to each of the dates in the dates series"/><node CREATED="1497319387558" ID="61gjk0ktn6o8mkoguqk8897thf" MODIFIED="1497319387558" TEXT="dates.strftime('%doodads') to make formatted dates"/><node CREATED="1497319387558" ID="7si7joe7dfn2mt33mfl4kc9f8o" MODIFIED="1497319387558" TEXT="moving window"><node CREATED="1497319387558" ID="0fj8mt0l4158glugvsl0vsihoi" MODIFIED="1497319387558" TEXT="let's you compute a value over a specific time window"/></node></node></node></map>